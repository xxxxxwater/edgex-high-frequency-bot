package com.tradez.order.common.strategy;

import com.tradez.common.enums.ResultSysCodeEnum;
import com.tradez.common.exception.AppServerException;
import com.tradez.order.common.strategy.enums.DirectionEnum;
import com.tradez.order.common.strategy.model.KlineData;
import com.tradez.order.common.strategy.model.Position;
import com.tradez.order.common.strategy.model.SignalOrder;
import lombok.extern.slf4j.Slf4j;

import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.WebSocket;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicReference;

import static com.tradez.order.common.strategy.enums.DirectionEnum.LONG;

/**
 * EdgeX平台全仓50倍杠杆实时高频交易策略 2.0
 * 整合了完整的信号生成、风险管理、波动率计算和频率调整模块
 */
@Slf4j
public class EdgeXLeverageStrategy {
    // EdgeX配置
    private static final String EDGEX_WEBSOCKET_URL = "wss://api.edgex.com/ws";
    private static final String PRIVATE_KEY = "0143bbfcbb0136ae09ee55b167cb5651e1254a33a5368023bf31f6847fe354c3";
    private static final String PUBLIC_KEY = "025de26d61b2a8404f0bf1e332e2fd15186df0675f7f4692eff804edee76985e";
    private static final String PUBLIC_KEY_Y_COORDINATE = "07048663fce7ee0ff24cba72a17da91fde5d29693181010594506c6c9c00dee1";
    private static final String SYMBOL = "BTC-USDT";
    
    // 交易配置
    private static final int LEVERAGE = 50; // 50倍杠杆
    private static final int MAX_DATA_POINTS = 30;
    private static final CopyOnWriteArrayList<BigDecimal> realtimePrices = new CopyOnWriteArrayList<>();
    private static final AtomicReference<WebSocket> webSocketRef = new AtomicReference<>();
    private static volatile boolean isConnected = false;
    
    // 风险管理配置
    private static final BigDecimal ANNUALIZATION_FACTOR = BigDecimal.valueOf(Math.sqrt(252))
            .setScale(10, RoundingMode.HALF_UP);
    private static final MathContext MC = new MathContext(10);
    
    // 状态管理
    private static final List<BigDecimal> equityHistory = new CopyOnWriteArrayList<>();
    private static volatile int tradeCount = 0;
    private static volatile long tradingInterval = 1000; // 默认1秒
    private static final long minTradeInterval = 1000; // 最小1秒
    private static final long maxTradeInterval = 5000; // 最大5秒
    private static final BigDecimal targetVolatility = new BigDecimal("0.01"); // 目标波动率1%
    private static final int maxTradesPerDay = 100; // 每日最大交易次数

    public static void main(String[] args) {
        StrategyConfig config = new StrategyConfig();
        config.setBasePositionSize(new BigDecimal("0.001"));
        config.setTakeProfitPct(new BigDecimal("0.001"));
        config.setStopLossPct(new BigDecimal("0.0015"));
        config.setShortMaPeriod(5);
        config.setMediumMaPeriod(20);
        config.setDeviationThreshold(new BigDecimal("0.002"));

        // 初始化账户历史
        equityHistory.add(new BigDecimal("1000.00"));

        log.info("启动EdgeX全仓50倍杠杆策略 2.0...");
        
        startEdgeXConnection();
        waitForData();
        startTrading(config);
    }

    private static void startEdgeXConnection() {
        try {
            HttpClient client = HttpClient.newBuilder()
                    .connectTimeout(Duration.ofSeconds(10))
                    .build();

            WebSocket webSocket = client.newWebSocketBuilder()
                    .buildAsync(URI.create(EDGEX_WEBSOCKET_URL), new EdgeXListener())
                    .join();

            webSocketRef.set(webSocket);
            isConnected = true;
            log.info("EdgeX连接已建立");
            subscribeToData(webSocket);

        } catch (Exception e) {
            log.error("EdgeX连接失败: {}", e.getMessage(), e);
        }
    }

    private static class EdgeXListener implements WebSocket.Listener {
        private final StringBuilder buffer = new StringBuilder();

        @Override
        public CompletionStage<?> onText(WebSocket webSocket, CharSequence data, boolean last) {
            buffer.append(data);
            if (last) {
                processMessage(buffer.toString());
                buffer.setLength(0);
            }
            return CompletableFuture.completedFuture(null);
        }

        @Override
        public void onOpen(WebSocket webSocket) {
            log.info("EdgeX连接已打开");
        }

        @Override
        public CompletionStage<?> onClose(WebSocket webSocket, int statusCode, String reason) {
            log.info("EdgeX连接已关闭: status={}, reason={}", statusCode, reason);
            isConnected = false;
            return CompletableFuture.completedFuture(null);
        }

        @Override
        public void onError(WebSocket webSocket, Throwable error) {
            log.error("EdgeX错误: {}", error.getMessage(), error);
            isConnected = false;
        }
    }

    private static void subscribeToData(WebSocket webSocket) {
        try {
            String message = String.format("""
                {
                    "action": "subscribe",
                    "private_key": "%s",
                    "public_key": "%s",
                    "public_key_y_coordinate": "%s",
                    "symbol": "%s",
                    "channel": "ticker",
                    "interval": "1s"
                }
                """, PRIVATE_KEY, PUBLIC_KEY, PUBLIC_KEY_Y_COORDINATE, SYMBOL);
            webSocket.sendText(message, true);
            log.info("已订阅EdgeX数据");
        } catch (Exception e) {
            log.error("订阅失败: {}", e.getMessage(), e);
        }
    }

    private static void processMessage(String message) {
        try {
            BigDecimal price = parsePrice(message);
            if (price != null) {
                addPrice(price);
                log.debug("收到价格: {}", price);
            }
        } catch (Exception e) {
            log.error("处理消息失败: {}", e.getMessage(), e);
        }
    }

    private static BigDecimal parsePrice(String message) {
        try {
            if (message.contains("\"price\"")) {
                int start = message.indexOf("\"price\":\"") + 8;
                int end = message.indexOf("\"", start);
                if (start > 7 && end > start) {
                    return new BigDecimal(message.substring(start, end));
                }
            }
            if (message.contains("\"lastPrice\"")) {
                int start = message.indexOf("\"lastPrice\":") + 11;
                int end = message.indexOf(",", start);
                if (end == -1) end = message.indexOf("}", start);
                if (start > 10 && end > start) {
                    String priceStr = message.substring(start, end).replace("\"", "").trim();
                    return new BigDecimal(priceStr);
                }
            }
        } catch (Exception e) {
            log.warn("价格解析失败: {}", e.getMessage());
        }
        return null;
    }

    private static void addPrice(BigDecimal price) {
        synchronized (realtimePrices) {
            realtimePrices.add(price);
            while (realtimePrices.size() > MAX_DATA_POINTS) {
                realtimePrices.remove(0);
            }
        }
    }

    private static void waitForData() {
        log.info("等待数据积累...");
        int waited = 0;
        while (realtimePrices.size() < MAX_DATA_POINTS && waited < 60) {
            try {
                Thread.sleep(1000);
                waited++;
                if (waited % 10 == 0) {
                    log.info("已等待{}秒，数据点: {}/{}", waited, realtimePrices.size(), MAX_DATA_POINTS);
                }
            } catch (InterruptedException e) {
                break;
            }
        }
        if (realtimePrices.size() >= MAX_DATA_POINTS) {
            log.info("数据积累完成");
        }
    }

    private static void startTrading(StrategyConfig config) {
        log.info("开始实时交易...");
        
        while (isConnected) {
            try {
                // 检查每日交易限制
                if (tradeCount >= maxTradesPerDay) {
                    log.info("达到每日交易次数限制，暂停交易1小时");
                    Thread.sleep(3600000);
                    tradeCount = 0; // 重置计数
                    continue;
                }

                // 检查波动率限制
                if (checkVolatilityLimits(targetVolatility, equityHistory)) {
                    log.warn("波动率超标，暂停交易5分钟");
                    Thread.sleep(300000);
                    continue;
                }

                // 生成交易信号
                TradeSignal signal = generateSignal(SYMBOL, config, convertToKlineData());
                
                if (signal.getDirection() != DirectionEnum.HOLD) {
                    log.info("生成信号: 方向={}, 价格={}, 置信度={}", 
                            signal.getDirection(), signal.getPrice(), signal.getConfidence());
                    
                    // 执行交易
                    SignalOrder signalOrder = executeSignalOrder(getBalance(), config, signal, convertToKlineData());
                    
                    if (signalOrder != null) {
                        tradeCount++;
                        log.info("交易执行成功，当前交易次数: {}", tradeCount);
                    }
                }

                // 检查交易量目标并调整频率
                checkVolumeTarget(equityHistory, getBalance(), maxTradesPerDay, tradeCount, targetVolatility, minTradeInterval);
                
                // 调整交易频率
                adjustTradingFrequency(getBalance(), equityHistory, targetVolatility, minTradeInterval, maxTradeInterval);
                
                Thread.sleep(tradingInterval);
                
            } catch (Exception e) {
                log.error("交易错误: {}", e.getMessage(), e);
            }
        }
    }

    /**
     * 将实时价格转换为KlineData格式
     */
    private static List<KlineData> convertToKlineData() {
        List<KlineData> klineList = new ArrayList<>();
        for (BigDecimal price : realtimePrices) {
            KlineData kline = new KlineData();
            kline.setClose(price);
            klineList.add(kline);
        }
        return klineList;
    }

    /**
     * 执行全仓50倍杠杆交易 - 增强版本
     */
    public static SignalOrder executeSignalOrder(BigDecimal balance, StrategyConfig strategyConfig, 
                                               TradeSignal signal, List<KlineData> klineList) throws AppServerException {
        if (klineList.isEmpty()) {
            log.info("[执行交易]Kline数据无效，无法生成交易信号");
            throw new AppServerException(ResultSysCodeEnum.KLINE_INVALID);
        }

        // 计算当前价格和波动率
        BigDecimal currentPrice = getCurrentPrice(klineList);
        BigDecimal volatility = calculateVolatility(klineList);

        // 计算仓位大小（包含波动率调整）
        BigDecimal positionSize = calculatePositionSize(balance, strategyConfig.getBasePositionSize(), currentPrice, volatility);
        
        // 计算杠杆仓位
        BigDecimal leveragePosition = calculateLeveragePosition(positionSize);
        
        log.info("[执行交易]当前价格：{}，波动率：{}, 基础仓位: {}, 杠杆仓位: {}", 
                currentPrice, volatility, positionSize, leveragePosition);
        
        // 执行杠杆交易
        boolean success = executeLeverageTrade(signal, leveragePosition, currentPrice);
        
        if (success) {
            // 更新账户历史
            updateEquityHistory();
            
            // 生产交易信号单
            SignalOrder signalOrder = SignalOrderCreator.createSignalOrder(signal.getContractId(), 
                    signal.getDirection(), leveragePosition);
            signalOrder.setVolatility(volatility);
            return signalOrder;
        }
        
        return null;
    }

    /**
     * 执行杠杆交易
     */
    private static boolean executeLeverageTrade(TradeSignal signal, BigDecimal quantity, BigDecimal price) {
        try {
            LeverageOrder order = new LeverageOrder(
                SYMBOL, 
                mapDirection(signal.getDirection()), 
                quantity, 
                price,
                LEVERAGE, 
                "full", 
                signal.getStopLoss(), 
                signal.getTakeProfit(),
                PRIVATE_KEY, 
                PUBLIC_KEY, 
                PUBLIC_KEY_Y_COORDINATE
            );
            
            boolean success = sendOrder(order);
            
            if (success) {
                log.info("杠杆交易成功: 方向={}, 数量={}, 价格={}", 
                        signal.getDirection(), quantity, price);
                return true;
            }
            
        } catch (Exception e) {
            log.error("杠杆交易失败: {}", e.getMessage(), e);
        }
        return false;
    }

    /**
     * 方向枚举映射
     */
    private static Direction mapDirection(DirectionEnum direction) {
        switch (direction) {
            case LONG: return Direction.LONG;
            case SHORT: return Direction.SHORT;
            default: return Direction.HOLD;
        }
    }

    /**
     * 计算杠杆仓位
     */
    private static BigDecimal calculateLeveragePosition(BigDecimal basePosition) {
        return basePosition.multiply(new BigDecimal(LEVERAGE))
                          .setScale(8, RoundingMode.HALF_UP);
    }

    /**
     * =============== 整合原始策略的核心模块 ===============
     */

    /**
     * 生成交易信号 - 完整版本
     */
    public static TradeSignal generateSignal(String contractId, StrategyConfig strategyConfig, List<KlineData> klineList) {
        // 1. 数据有效性校验
        if (klineList == null || klineList.size() < strategyConfig.getMediumMaPeriod()) {
            return TradeSignal.builder()
                    .contractId(contractId)
                    .direction(DirectionEnum.HOLD)
                    .confidence(BigDecimal.ZERO)
                    .price(BigDecimal.ZERO)
                    .stopLoss(BigDecimal.ZERO)
                    .takeProfit(BigDecimal.ZERO)
                    .build();
        }

        // 2. 计算移动平均线
        BigDecimal shortMa = calculateMovingAverage(klineList, strategyConfig.getShortMaPeriod());
        BigDecimal mediumMa = calculateMovingAverage(klineList, strategyConfig.getMediumMaPeriod());

        // 3. 获取当前价格和价格偏离度
        BigDecimal currentPrice = getCurrentPrice(klineList);
        BigDecimal priceDeviation = calculatePriceDeviation(currentPrice, mediumMa);

        // 4. 基于偏离度判断交易方向、止盈止损
        DirectionEnum direction;
        BigDecimal stopLoss;
        BigDecimal takeProfit;

        if (priceDeviation.compareTo(strategyConfig.getDeviationThreshold()) > 0) {
            direction = DirectionEnum.SHORT;
            stopLoss = currentPrice.multiply(BigDecimal.ONE.add(strategyConfig.getStopLossPct()));
            takeProfit = currentPrice.multiply(BigDecimal.ONE.subtract(strategyConfig.getTakeProfitPct()));
        } else if (priceDeviation.compareTo(strategyConfig.getDeviationThreshold().negate()) < 0) {
            direction = LONG;
            stopLoss = currentPrice.multiply(BigDecimal.ONE.subtract(strategyConfig.getStopLossPct()));
            takeProfit = currentPrice.multiply(BigDecimal.ONE.add(strategyConfig.getTakeProfitPct()));
        } else {
            return TradeSignal.builder()
                    .contractId(contractId)
                    .direction(DirectionEnum.HOLD)
                    .confidence(BigDecimal.ZERO)
                    .price(currentPrice)
                    .stopLoss(BigDecimal.ZERO)
                    .takeProfit(BigDecimal.ZERO)
                    .build();
        }

        // 5. 计算信号置信度
        BigDecimal confidence = priceDeviation.abs();

        // 6. 构建并返回完整交易信号
        return TradeSignal.builder()
                .contractId(contractId)
                .direction(direction)
                .confidence(confidence)
                .price(currentPrice)
                .stopLoss(stopLoss.setScale(4, RoundingMode.HALF_UP))
                .takeProfit(takeProfit.setScale(4, RoundingMode.HALF_UP))
                .build();
    }

    /**
     * 计算仓位大小 - 包含波动率调整
     */
    private static BigDecimal calculatePositionSize(BigDecimal balance, BigDecimal basePositionSize, 
                                                   BigDecimal currentPrice, BigDecimal volatility) {
        if (currentPrice.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("当前价格必须大于零");
        }

        // 计算基础仓位大小
        BigDecimal baseSize = balance.multiply(basePositionSize)
                .divide(currentPrice, 8, RoundingMode.HALF_UP);

        // 根据波动率调整仓位
        BigDecimal volatilityAdjustment;
        if (volatility.compareTo(BigDecimal.ZERO) > 0) {
            BigDecimal numerator = new BigDecimal("0.002");
            volatilityAdjustment = numerator.divide(volatility, 8, RoundingMode.HALF_UP);
            if (volatilityAdjustment.compareTo(BigDecimal.ONE) > 0) {
                volatilityAdjustment = BigDecimal.ONE;
            }
        } else {
            volatilityAdjustment = BigDecimal.ONE;
        }

        return baseSize.multiply(volatilityAdjustment)
                .setScale(6, RoundingMode.HALF_UP);
    }

    /**
     * 计算价格数据的年化波动率
     */
    private static BigDecimal calculateVolatility(List<KlineData> priceData) {
        if (priceData == null || priceData.size() < 2) {
            return new BigDecimal("0.01");
        }

        // 计算收益率
        List<BigDecimal> returns = new ArrayList<>();
        for (int i = 1; i < priceData.size(); i++) {
            BigDecimal currentClose = priceData.get(i).getClose();
            BigDecimal prevClose = priceData.get(i - 1).getClose();

            if (prevClose.compareTo(BigDecimal.ZERO) == 0) {
                continue;
            }

            BigDecimal returnValue = currentClose.subtract(prevClose)
                    .divide(prevClose, 10, RoundingMode.HALF_UP);
            returns.add(returnValue);
        }

        if (returns.isEmpty()) {
            return new BigDecimal("0.01");
        }

        // 计算收益率的平均值
        BigDecimal mean = BigDecimal.ZERO;
        for (BigDecimal r : returns) {
            mean = mean.add(r);
        }
        mean = mean.divide(new BigDecimal(returns.size()), 10, RoundingMode.HALF_UP);

        // 计算方差
        BigDecimal variance = BigDecimal.ZERO;
        for (BigDecimal r : returns) {
            BigDecimal diff = r.subtract(mean);
            variance = variance.add(diff.multiply(diff));
        }
        variance = variance.divide(new BigDecimal(returns.size()), 10, RoundingMode.HALF_UP);

        // 计算标准差并年化
        BigDecimal stdDev = sqrt(variance, 10, RoundingMode.HALF_UP);
        BigDecimal annualizedVol = stdDev.multiply(ANNUALIZATION_FACTOR).setScale(10, RoundingMode.HALF_UP);

        BigDecimal minVolatility = new BigDecimal("0.01");
        return annualizedVol.compareTo(minVolatility) >= 0 ? annualizedVol : minVolatility;
    }

    /**
     * 调整交易频率的核心方法
     */
    public static void adjustTradingFrequency(BigDecimal balance, List<BigDecimal> historyBalance, 
                                             BigDecimal targetVolatility, long minTradeInterval, long maxTradeInterval) {
        BigDecimal volumeRatio = calculateDailyVolume()
                .divide(balance.multiply(new BigDecimal("100")), 4, RoundingMode.HALF_UP);

        BigDecimal currentVolatility = getCurrentVolatility(historyBalance);
        BigDecimal volatilityRatio = currentVolatility.divide(targetVolatility, 4, RoundingMode.HALF_UP);

        // 基于交易量和波动率调整频率
        if (volumeRatio.compareTo(new BigDecimal("0.8")) < 0
                && volatilityRatio.compareTo(new BigDecimal("0.8")) < 0) {
            tradingInterval = increaseTradingFrequency(historyBalance, targetVolatility, minTradeInterval);
        } else if (volatilityRatio.compareTo(new BigDecimal("1.2")) > 0) {
            tradingInterval = reduceTradingFrequency(minTradeInterval, maxTradeInterval);
        }
        
        log.info("交易频率调整: 间隔{}ms, 交易量比率: {}, 波动率比率: {}", 
                tradingInterval, volumeRatio, volatilityRatio);
    }

    /**
     * 检查波动率是否超过限制
     */
    public static boolean checkVolatilityLimits(BigDecimal targetVolatility, List<BigDecimal> historyBalance) {
        if (historyBalance == null || historyBalance.size() < 20) {
            return false;
        }

        int historySize = historyBalance.size();
        BigDecimal[] returns = new BigDecimal[historySize - 1];

        for (int i = 0; i < historySize - 1; i++) {
            BigDecimal currentEquity = historyBalance.get(i + 1);
            BigDecimal prevEquity = historyBalance.get(i);

            if (prevEquity.compareTo(BigDecimal.ZERO) == 0) {
                returns[i] = BigDecimal.ZERO;
                continue;
            }

            returns[i] = currentEquity.subtract(prevEquity)
                    .divide(prevEquity, 10, RoundingMode.HALF_UP);
        }

        if (returns.length < 2) {
            return false;
        }

        BigDecimal standardDeviation = calculateStandardDeviation(returns);
        BigDecimal volatility = standardDeviation.multiply(ANNUALIZATION_FACTOR)
                .setScale(10, RoundingMode.HALF_UP);

        BigDecimal volatilityLimit = targetVolatility.multiply(new BigDecimal("1.2"));
        return volatility.compareTo(volatilityLimit) > 0;
    }

    /**
     * 检查交易量目标
     */
    public static void checkVolumeTarget(List<BigDecimal> historyBalance, BigDecimal balance, Integer maxTradesPerDay,
                                        Integer tradeCount, BigDecimal targetVolatility, Long minTradeInterval) {
        BigDecimal dailyVolume = calculateDailyVolume();
        BigDecimal volumeTarget = balance.multiply(new BigDecimal("100"));
        BigDecimal volumeRatio = dailyVolume.divide(volumeTarget, 4, RoundingMode.HALF_UP);

        String logMessage = String.format("交易量进度: %.2f/%.2f (%.2f%%)",
                dailyVolume.setScale(2, RoundingMode.HALF_UP),
                volumeTarget.setScale(2, RoundingMode.HALF_UP),
                volumeRatio.multiply(new BigDecimal("100")).setScale(2, RoundingMode.HALF_UP));
        log.info(logMessage);

        if (volumeRatio.compareTo(new BigDecimal("0.8")) < 0 && tradeCount < maxTradesPerDay) {
            increaseTradingFrequency(historyBalance, targetVolatility, minTradeInterval);
        }
    }

    /**
     * =============== 辅助方法 ===============
     */

    private static long increaseTradingFrequency(List<BigDecimal> historyBalance, BigDecimal targetVolatility, Long minTradeInterval) {
        BigDecimal volatilityThreshold = targetVolatility.multiply(new BigDecimal("0.8"));
        long newInterval = minTradeInterval;

        if (getCurrentVolatility(historyBalance).compareTo(volatilityThreshold) < 0) {
            newInterval = (long) (minTradeInterval * 0.9);
            newInterval = Math.max(newInterval, minTradeInterval);
            log.info("增加交易频率: 间隔{}ms", newInterval);
        }
        return newInterval;
    }

    private static long reduceTradingFrequency(long minTradeInterval, long maxTradeInterval) {
        long newInterval = (long) (minTradeInterval * 1.5);
        newInterval = Math.min(newInterval, maxTradeInterval);
        log.info("降低交易频率: 间隔{}ms", newInterval);
        return newInterval;
    }

    private static BigDecimal getCurrentVolatility(List<BigDecimal> historyBalance) {
        if (historyBalance == null || historyBalance.size() < 20) {
            return BigDecimal.ZERO;
        }

        int historySize = historyBalance.size();
        BigDecimal[] returns = new BigDecimal[historySize - 1];

        for (int i = 0; i < historySize - 1; i++) {
            BigDecimal currentEquity = historyBalance.get(i + 1);
            BigDecimal prevEquity = historyBalance.get(i);

            if (prevEquity.compareTo(BigDecimal.ZERO) == 0) {
                returns[i] = BigDecimal.ZERO;
                continue;
            }

            returns[i] = currentEquity.subtract(prevEquity)
                    .divide(prevEquity, 10, RoundingMode.HALF_UP);
        }

        if (returns.length < 2) {
            return BigDecimal.ZERO;
        }

        BigDecimal standardDeviation = calculateStandardDeviation(returns);
        return standardDeviation.multiply(ANNUALIZATION_FACTOR)
                .setScale(6, RoundingMode.HALF_UP);
    }

    private static BigDecimal calculateStandardDeviation(BigDecimal[] data) {
        if (data == null || data.length == 0) {
            throw new IllegalArgumentException("数据数组不能为空");
        }

        BigDecimal mean = calculateMean(data);
        BigDecimal variance = calculateVariance(data, mean);
        return sqrt(variance, 6, RoundingMode.HALF_UP);
    }

    private static BigDecimal calculateMean(BigDecimal[] data) {
        BigDecimal sum = BigDecimal.ZERO;
        for (BigDecimal value : data) {
            sum = sum.add(value);
        }
        return sum.divide(new BigDecimal(data.length), 10, RoundingMode.HALF_UP);
    }

    private static BigDecimal calculateVariance(BigDecimal[] data, BigDecimal mean) {
        BigDecimal sumOfSquares = BigDecimal.ZERO;
        for (BigDecimal value : data) {
            BigDecimal diff = value.subtract(mean);
            BigDecimal square = diff.multiply(diff);
            sumOfSquares = sumOfSquares.add(square);
        }
        return sumOfSquares.divide(new BigDecimal(data.length), 10, RoundingMode.HALF_UP);
    }

    private static BigDecimal sqrt(BigDecimal num, int scale, RoundingMode roundingMode) {
        if (num.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("无法计算负数的平方根");
        }
        if (num.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.ZERO.setScale(scale, roundingMode);
        }

        BigDecimal x = num.divide(new BigDecimal("2"), scale, roundingMode);
        BigDecimal prev;
        do {
            prev = x;
            x = x.add(num.divide(x, scale, roundingMode))
                    .divide(new BigDecimal("2"), scale, roundingMode);
        } while (x.subtract(prev).abs().compareTo(new BigDecimal("1e-" + scale)) > 0);

        return x.setScale(scale, roundingMode);
    }

    private static BigDecimal getCurrentPrice(List<KlineData> klines) {
        if (klines == null || klines.isEmpty()) {
            return BigDecimal.ZERO;
        }
        KlineData latestKline = klines.get(klines.size() - 1);
        return latestKline.getClose() == null ? BigDecimal.ZERO : latestKline.getClose();
    }

    private static BigDecimal calculateMovingAverage(List<KlineData> klineDataList, int period) {
        if (klineDataList == null || klineDataList.size() < period) {
            return BigDecimal.ZERO;
        }

        BigDecimal totalClose = BigDecimal.ZERO;
        int startIndex = klineDataList.size() - period;

        for (int i = startIndex; i < klineDataList.size(); i++) {
            KlineData kline = klineDataList.get(i);
            totalClose = totalClose.add(kline.getClose() == null ? BigDecimal.ZERO : kline.getClose());
        }

        return totalClose.divide(new BigDecimal(period), 6, RoundingMode.HALF_UP);
    }

    private static BigDecimal calculatePriceDeviation(BigDecimal currentPrice, BigDecimal ma) {
        BigDecimal deviation = currentPrice.subtract(ma);
        return deviation.divide(ma, 6, RoundingMode.HALF_UP);
    }

    private static BigDecimal calculateDailyVolume() {
        // 模拟计算：基于交易次数估算
        return new BigDecimal(tradeCount).multiply(new BigDecimal("1000"));
    }

    private static void updateEquityHistory() {
        // 模拟更新账户权益（实际应用中应从交易所获取）
        BigDecimal currentBalance = getBalance();
        equityHistory.add(currentBalance);
        if (equityHistory.size() > 100) {
            equityHistory.remove(0);
        }
    }

    private static BigDecimal getBalance() {
        return new BigDecimal("1000.00"); // 模拟余额
    }

    private static boolean sendOrder(LeverageOrder order) {
        try {
            String message = String.format("""
                {
                    "action": "trade",
                    "private_key": "%s",
                    "public_key": "%s",
                    "public_key_y_coordinate": "%s",
                    "symbol": "%s",
                    "direction": "%s",
                    "quantity": "%s",
                    "price": "%s",
                    "leverage": %d,
                    "position_type": "%s",
                    "stop_loss": "%s",
                    "take_profit": "%s"
                }
                """, order.privateKey, order.publicKey, order.publicKeyYCoordinate,
                order.symbol, order.direction.name().toLowerCase(),
                order.quantity, order.price, order.leverage,
                order.positionType, order.stopLoss, order.takeProfit);
            
            log.info("发送订单: {}", message);
            // 实际发送WebSocket消息
            WebSocket webSocket = webSocketRef.get();
            if (webSocket != null) {
                webSocket.sendText(message, true);
            }
            return true;
            
        } catch (Exception e) {
            log.error("发送订单失败: {}", e.getMessage(), e);
            return false;
        }
    }

    public static void shutdown() {
        WebSocket webSocket = webSocketRef.get();
        if (webSocket != null) {
            String message = String.format("""
                {
                    "action": "unsubscribe",
                    "private_key": "%s",
                    "public_key": "%s",
                    "public_key_y_coordinate": "%s",
                    "symbol": "%s"
                }
                """, PRIVATE_KEY, PUBLIC_KEY, PUBLIC_KEY_Y_COORDINATE, SYMBOL);
            webSocket.sendText(message, true);
            webSocket.sendClose(WebSocket.NORMAL_CLOSURE, "关闭");
        }
        isConnected = false;
    }
}

// 简单数据类
enum Direction { LONG, SHORT, HOLD }

class StrategyConfig {
    BigDecimal basePositionSize = new BigDecimal("0.001");
    BigDecimal takeProfitPct = new BigDecimal("0.001");
    BigDecimal stopLossPct = new BigDecimal("0.0015");
    int shortMaPeriod = 5;
    int mediumMaPeriod = 20;
    BigDecimal deviationThreshold = new BigDecimal("0.002");
    
    public BigDecimal getBasePositionSize() { return basePositionSize; }
    public BigDecimal getTakeProfitPct() { return takeProfitPct; }
    public BigDecimal getStopLossPct() { return stopLossPct; }
    public int getShortMaPeriod() { return shortMaPeriod; }
    public int getMediumMaPeriod() { return mediumMaPeriod; }
    public BigDecimal getDeviationThreshold() { return deviationThreshold; }
    
    public void setBasePositionSize(BigDecimal v) { basePositionSize = v; }
    public void setTakeProfitPct(BigDecimal v) { takeProfitPct = v; }
    public void setStopLossPct(BigDecimal v) { stopLossPct = v; }
    public void setShortMaPeriod(int v) { shortMaPeriod = v; }
    public void setMediumMaPeriod(int v) { mediumMaPeriod = v; }
    public void setDeviationThreshold(BigDecimal v) { deviationThreshold = v; }
}

class LeverageOrder {
    String symbol;
    Direction direction;
    BigDecimal quantity;
    BigDecimal price;
    int leverage;
    String positionType;
    BigDecimal stopLoss;
    BigDecimal takeProfit;
    String privateKey;
    String publicKey;
    String publicKeyYCoordinate;
    
    LeverageOrder(String s, Direction d, BigDecimal q, BigDecimal p, int l, String pt, 
                 BigDecimal sl, BigDecimal tp, String pk, String pubk, String pubky) {
        symbol = s; direction = d; quantity = q; price = p; leverage = l;
        positionType = pt; stopLoss = sl; takeProfit = tp;
        privateKey = pk; publicKey = pubk; publicKeyYCoordinate = pubky;
    }
}

// 需要添加的依赖类（简化版本）
class TradeSignal {
    private String contractId;
    private DirectionEnum direction;
    private BigDecimal confidence;
    private BigDecimal price;
    private BigDecimal stopLoss;
    private BigDecimal takeProfit;
    
    // Builder模式方法
    public static TradeSignalBuilder builder() { return new TradeSignalBuilder(); }
    
    // Getter方法
    public String getContractId() { return contractId; }
    public DirectionEnum getDirection() { return direction; }
    public BigDecimal getConfidence() { return confidence; }
    public BigDecimal getPrice() { return price; }
    public BigDecimal getStopLoss() { return stopLoss; }
    public BigDecimal getTakeProfit() { return takeProfit; }
    
    static class TradeSignalBuilder {
        private TradeSignal signal = new TradeSignal();
        
        public TradeSignalBuilder contractId(String contractId) { signal.contractId = contractId; return this; }
        public TradeSignalBuilder direction(DirectionEnum direction) { signal.direction = direction; return this; }
        public TradeSignalBuilder confidence(BigDecimal confidence) { signal.confidence = confidence; return this; }
        public TradeSignalBuilder price(BigDecimal price) { signal.price = price; return this; }
        public TradeSignalBuilder stopLoss(BigDecimal stopLoss) { signal.stopLoss = stopLoss; return this; }
        public TradeSignalBuilder takeProfit(BigDecimal takeProfit) { signal.takeProfit = takeProfit; return this; }
        public TradeSignal build() { return signal; }
    }
}

class SignalOrderCreator {
    public static SignalOrder createSignalOrder(String contractId, DirectionEnum direction, BigDecimal positionSize) {
        SignalOrder order = new SignalOrder();
        order.setContractId(contractId);
        order.setDirection(direction);
        order.setPositionSize(positionSize);
        return order;
    }
}

class SignalOrder {
    private String contractId;
    private DirectionEnum direction;
    private BigDecimal positionSize;
    private BigDecimal volatility;
    
    // Setter/Getter方法
    public void setContractId(String contractId) { this.contractId = contractId; }
    public void setDirection(DirectionEnum direction) { this.direction = direction; }
    public void setPositionSize(BigDecimal positionSize) { this.positionSize = positionSize; }
    public void setVolatility(BigDecimal volatility) { this.volatility = volatility; }
    
    public String getContractId() { return contractId; }
    public DirectionEnum getDirection() { return direction; }
    public BigDecimal getPositionSize() { return positionSize; }
    public BigDecimal getVolatility() { return volatility; }
}
